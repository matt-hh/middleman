#!/usr/bin/env ruby

require 'optparse'

# Require Middleman
require File.join(File.dirname(__FILE__), '..', 'lib', 'middleman')

env = ENV['MM_ENV'] || ENV['RACK_ENV'] || 'development'
options = { :Port => 4567, :AccessLog => [] }

# TODO: Switch to Thor
OptionParser.new { |opts|
  opts.banner = "Usage: mm-server [rack options]"
  opts.separator ""
  opts.separator "Rack options:"
  opts.on("-p", "--port PORT", "use PORT (default: 4567)") { |port|
    options[:Port] = port
  }
  opts.on("-E", "--env ENVIRONMENT", "use ENVIRONMENT for defaults (default: development)") { |e|
    env = e
  }
  opts.on("--debug", "Debug mode") {
    ::Middleman::Server.set :logging, true
  }

  opts.parse! ARGV
}

ENV['RACK_ENV'] = env

@current_path = Dir.pwd
@path_parts = @current_path.split("/")
@found_root = false

while (!@found_root && (@path_parts.length > 0))
  @current_path = File.join(*@path_parts)

  source_folder = File.join(@current_path, "source")

  if File.exists?(source_folder)
    @found_root = true
    next
  end

  @path_parts.pop
end

if !@found_root
  $stderr.puts "== Error: Could not find a Middleman project structure, perhaps you are in the wrong folder?"
  exit
end

# If the old init.rb exists, issue warning
old_config = File.join(@current_path, "init.rb")
if File.exists? old_config
  $stderr.puts "== Error: The init.rb file (deprecated) needs to be be renamed to config.rb"
  exit
end

# If the old directories exists, use it, but issue warning
old_views = File.join(@current_path, "views")
old_public = File.join(@current_path, "public")
if File.exists?(old_views) || File.exists?(old_public)
  $stderr.puts "== Error: The views and public folders are have been combined. Create a new 'source' folder, add the contents of views and public to it and then remove the empty views and public folders."
  exit
end

Middleman::Server.root = @current_path
options[:app]    = Middleman::Server.new
# options[:server] = 'webrick'

# puts "== The Middleman is standing watch on port #{options[:Port]}"
# Rack::Server.new(options).start



if Gem.available?('guard')
  require 'guard'
  puts "== The Middleman is starting with guard support"

  require 'guard/guard'
  module ::Guard
    class MiddlemanServerGuard < ::Guard::Guard
      def start
        server_start
      end
      def run_on_change(paths)
        server_stop
        server_start
      end
      private
        def server_start
          puts "== The Middleman is standing watch on port #{options[:Port]}"
          @server_options = { :Port => 4567, :AccessLog => [] }
          @server_job = fork do
            @server_options[:app] = Middleman::Server.new
            Rack::Server.new(@server_options).start
          end
        end
        def server_stop
          puts "== The Middleman is going to shutdown"
          Process.kill("KILL", @server_job)
          Process.wait @server_job
          @server_job = nil
          @server_options[:app] = nil
        end
    end
  end

  guardfile = File.join(@current_path, "Guardfile")
  guardfile_contents = File.exists?(guardfile) ? File.open(guardfile, "r").read : ""

  inline_guardfile_contents = "guard 'MiddlemanServerGuard' do watch(%r{config\.rb}) end"

  guard_options = {
    :guardfile_contents => inline_guardfile_contents << guardfile_contents
  }
  Guard.start(guard_options)

else
  puts "== The Middleman is standing watch on port #{options[:Port]}"
  Rack::Server.new(options).start
end